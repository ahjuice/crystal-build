#!/usr/bin/env perl

use strict;
use warnings;
use utf8;

use feature qw/say/;

# -----------------------------------------------------------------------------

package Crenv;

use File::Path qw/rmtree mkpath/;

sub new {
    my ($class, %opt) = @_;

    my $self = +{ %opt };
    bless $self => $class;

    $self->init;
    $self;
}

sub init {
    my $self = shift;

    $self->{versions_dir} = $self->{prefix} . '/versions';
    $self->{cache_dir} = $self->{prefix} . '/cache';
}

sub install {
    my ($self, $v) = @_;

    my ($platform, $arch) = Crenv::Utils::system_info();

    if ($arch ne 'x64') {
        my $p = ucfirst $platform;
        say "WARNING!! Crystal binary is not supported $arch $p OS at the moment.";
    }

    my $version      = $self->find_install_version($v);
    my $cache_dir    = "$self->{cache_dir}/$version";
    my $target_name  = "crystal-$version-$platform-$arch";
    my $tarball_path = "$cache_dir/$target_name.tar.gz";

    say "resolve: $target_name";
    my $release       = $self->github->fetch_release($version);
    my $download_urls = $self->find_binary_download_urls($release->{assets});

    error_and_exit('version not found') unless defined $download_urls->{$platform};

    my $tarball_url = $download_urls->{$platform};

    # clean
    $self->clean($version);
    mkpath $cache_dir;

    say "fetch: $tarball_url";
    $self->{fetcher}->download($tarball_url, $tarball_path)
        or error_and_exit("download faild: $tarball_url");

    Crenv::Utils::extract_tar($tarball_path, $cache_dir);

    my ($target_dir) = glob "$cache_dir/crystal-*/";
    rename $target_dir, $self->get_install_dir . "/$version" or die "Error: $!";

    say 'Install successful';
}

sub show_definitions {
    my ($self) = @_;

    my $releases        = $self->github->fetch_releases;
    my @tag_names       = map { $_->{tag_name} } @$releases;
    my @versions        = map { $self->normalize_version($_) } @tag_names;
    my $sorted_versions = Crenv::Utils::sort_version(\@versions);

    say $_ for @$sorted_versions;
}

sub find_install_version {
    my ($self, $v) = @_;

    my $version = $self->normalize_version($v);

    error_and_exit('version not found') unless $version;
    error_and_exit("$version is already installed")
        if -e $self->get_install_dir . "/$version";

    return $version;
}

sub find_binary_download_urls {
    my ($self, $assets) = @_;

    my ($linux)  = grep { $_->{name} =~ /linux/  } @$assets;
    my ($darwin) = grep { $_->{name} =~ /darwin/ } @$assets;

    +{
        linux  => $linux->{browser_download_url},
        darwin => $darwin->{browser_download_url},
    };
}

sub get_install_dir {
    my $self = shift;

    my $dir = $self->{versions_dir};
    mkpath $dir unless -e $dir;

    return $dir;
}

sub normalize_version {
    my ($self, $v) = @_;

    error_and_exit('version is required') unless $v;

    return $v if $v =~ m/^\d+\.?(\d+|x)?\.?(\d+|x)?$/;
    return do { $v =~ s/v//; $v } if $v =~ m/^v\d+\.?(\d+|x)?\.?(\d+|x)?$/;
    return $v;
}

sub error_and_exit {
    my $msg = shift;

    say $msg;
    exit 1;
}

sub clean {
    my ($self, $version) = @_;

    if ($version eq 'all') {
        opendir my $dh, $self->{cache_dir} or return;
        while (my $file = readdir $dh) {
            next if $file =~ m/^\./;
            my $path = "$self->{cache_dir}/$file";
            unlink $path if -f $path;
            rmtree $path if -d $path;
        }
    }
    elsif (-d "$self->{cache_dir}/$version") {
        rmtree "$self->{cache_dir}/$version";
    }
}

sub github {
    my $self = shift;

    Crenv::GitHub->new(
        fetcher     => $self->{fetcher},
        github_repo => $self->{github_repo},
    );
}

# -----------------------------------------------------------------------------

package Crenv::GitHub;

BEGIN {
    eval {
        require JSON::PP;
        JSON::PP->import;
    };

    # if VERSION < 5.13.9
    if ($@) {
        no warnings 'once';

        require FindBin;
        require lib;

        lib->import($FindBin::Bin . '/../lib');

        require JSON::PP;
        JSON::PP->import;

        say 'Can\'t load JSON::PP module. Please check Perl version.' if $@;
    }
}

sub new {
    my ($class, %opt) = @_;

    my $self = +{ %opt };
    bless $self => $class;
}

sub fetch {
    my ($self, $url) = @_;
    $self->{fetcher}->fetch_from_github($url);
}

sub base_url {
    my $self = shift;
    'https://api.github.com/repos/' . $self->{github_repo} . '/';
}

sub fetch_as_json {
    my ($self, $path) = @_;

    my $url      = $self->base_url . $path;
    my $content  = $self->fetch($url);
    decode_json($content);
}

sub fetch_release {
    my ($self, $version) = @_;
    $self->fetch_as_json('releases/tags/' . $version);
}

sub fetch_releases {
    my ($self) = @_;
    $self->fetch_as_json('releases?per_page=100');
}

# -----------------------------------------------------------------------------

package Crenv::Utils;

use POSIX;
use Getopt::Long qw/:config posix_default no_ignore_case gnu_compat/;

sub sort_version {
    my $version = shift;

    return [sort {
        my ($a1, $a2, $a3) = ($a =~ m/(\d+)\.(\d+)\.(\d+)/);
        my ($b1, $b2, $b3) = ($b =~ m/(\d+)\.(\d+)\.(\d+)/);
        $a1 <=> $b1 || $a2 <=> $b2 || $a3 <=> $b3
    } @$version];
}

sub system_info {
    my $arch;
    my ($sysname, $machine) = (POSIX::uname)[0, 4];

    if  ($machine =~ m/x86_64/) {
        $arch = 'x64';
    } elsif ($machine =~ m/i\d86/) {
        $arch = 'x86';
    } elsif ($machine =~ m/armv6l/) {
        $arch = 'arm-pi';
    } elsif ($sysname =~ m/sunos/i) {
        # SunOS $machine => 'i86pc'. but use 64bit kernel.
        # Solaris 11 not support 32bit kernel.
        # both 32bit and 64bit node-binary even work on 64bit kernel
        $arch = 'x64';
    } else {
        die "Error: $sysname $machine is not supported."
    }

    return (lc $sysname, $arch);
}

sub extract_tar {
    my ($filepath, $outdir) = @_;

    my $cwd = getcwd;

    chdir($outdir);

    eval {
        require Archive::Tar;
        my $tar = Archive::Tar->new;
        $tar->read($filepath);
        $tar->extract;
    };
    if ($@) {
        `tar zfx $filepath`;
    }

    chdir($cwd);
}

sub parse_args {
    my ($version, $prefix) = @_[-2,-1];
    my $definitions;

    GetOptions(
        definitions => \$definitions
    );

    return {
        version     => $version,
        prefix      => $prefix,
        definitions => $definitions,
    };
}

# -----------------------------------------------------------------------------

package Crenv::Fetcher;

sub get {
    my ($class, $type) = @_;

    $type eq 'wget' ? Crenv::Fetcher::Wget->new:
    $type eq 'curl' ? Crenv::Fetcher::Curl->new:
    die 'Fetcher type invalid';
}

# -----------------------------------------------------------------------------

package Crenv::Fetcher::Curl;

sub new { bless {} }

sub fetch_able {
    my ($self, $url) = @_;

    `curl -LIs "$url"` =~ m/200 OK/;
}

sub fetch {
    my ($self, $url) = @_;

    `curl -Ls $url`;
}

sub fetch_from_github {
    my ($self, $url) = @_;

    `curl -H 'Accept: application/vnd.github.v3+json' -Ls $url`;
}

sub download {
    my ($self, $url, $path) = @_;

    system("curl -L $url -o $path") == 0;
}

# -----------------------------------------------------------------------------

package Crenv::Fetcher::Wget;

sub new { bless {} }

sub fetch_able {
    my ($self, $url) = @_;

    `wget -Sq --spider "$url" 2>&1` =~ m/200 OK/;
}

sub fetch {
    my ($self, $url) = @_;

    `wget -q $url -O -`;
}

sub fetch_from_github {
    my ($self, $url) = @_;

    `wget -q $url --header='Accept: application/vnd.github.v3+json' -O -`;
}

sub download {
    my ($self, $url, $path) = @_;

    system("wget -c $url -O $path") == 0;
}

# -----------------------------------------------------------------------------

package main;

use Cwd qw/abs_path/;

sub main {
    my $args = Crenv::Utils::parse_args(@ARGV);
    my $github_repo        = 'manastech/crystal';

    my $crenv = Crenv->new(
        prefix      => $args->{prefix},
        fetcher     => Crenv::Fetcher->get(fetcher_type()),
        github_repo => $github_repo,
    );

    if ($args->{definitions}) {
        $crenv->show_definitions;
    }

    else {
        $crenv->install($args->{version});
    }
}

sub fetcher_type {
    `which curl` ? 'curl' :
    `which wget` ? 'wget' :
        die 'Need curl or wget';
}

main unless caller;

# vim: se et ts=4 sw=4 sts=4 ft=perl :
